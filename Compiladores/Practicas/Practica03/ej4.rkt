#lang nanopass
(require nanopass/base
         parser-tools/lex
         (prefix-in : parser-tools/lex-sre);Operadores
         (prefix-in re- parser-tools/lex-sre)
         parser-tools/yacc)

(define-language LF
  (terminals
   (variable (x))
   (primitive (pr))
   (constant (c))
   (string (s))
   (char (c1))
   (type (t))
   (lista (l)))
  (Expr (e body)
        x
        pr
        c
        s
        c1
        t
        l
        (begin e* ... e)
        (if e0 e1)
        (if e0 e1 e2)
        (fun ((x* t*) ...) t body* ... body)
        (let ((x* t* e*) ...) body* ... body)
        (funF x ((x* t*) ...) t body* ... body)
        (e0 e1 ...)
        (pr e* ... e)))

(define (variable? x)
  (and (symbol? x) (not (memq x '(and or + - * / > <)))))

(define (type? t)
 (or (equal? t 'Int) (equal? t 'Bool) (eq? t 'String) (eq? t 'Char)))

(define (lista? x)
  (list? x))

;; Si solo dejamos procedure? nos toma las operaciones como si fueran variables.
(define (primitive? x)
  (or (procedure? x) (memq x '(and or + - * / > <))))

(define (constant? x)
  (or (number? x) (boolean? x)))

(define-parser parse-LF LF)


;; ====================  E4 =======================

; For the rename-var

; Tokens for the lexer
(define-tokens a1 (NUM1 VAR1))
(define-empty-tokens b1 (EOF))

; A lexer for the variables.
; Takes an alphanumeric string and returns a list of tokens, where each token is
; a number or a string.
(define var-lexer
  (lexer
   [(:: (:+ (char-range #\a #\z) (:+ (char-range #\A #\Z))))
    ; =>
    (cons  `(VAR1 ,(string->symbol lexeme)) (var-lexer input-port))];; pvto

   [(:: (:: (:+ (char-range #\0 #\9)) (:* (char-range #\0 #\9))))
    ; =>
    (cons `(NUM1 ,(string->number lexeme)) (var-lexer input-port))];; 90909

   [(eof)
    `()]))

; Function that takes a list [x1,...,xn-1,xn] and
; returns the list [x1,...,xn-1]
(define (init l)
  (take l (- (length l) 1)))

; Function that takes a list of tokens [t1,...,tn] and if the last token is
; a number n, returns [t1,...,n+1]; otherwise, returns [t1,...,tn,0]
(define (newName lToks)
  (let ([ultimo (last (last lToks))])
    (if (number? ultimo)
        (append (init lToks) (list (quasiquote (NUM1 (unquote (add1 ultimo))))))
        (append lToks (list '(NUM1 0))))))

; Function that takes a function that given a list of tokens,
; flats the list of tokens into a string
(define (constructVar lToks) ;; ["c" "h" ] -> "ch" | "hc"
  (string-join (foldr (lambda (tok l) (cons (format "~a" (last tok)) l)) '() lToks) ""))
  
; Function that takes a symbol that represents a name of a variable
; and returns a fresh name of variable as a string
(define (newVar x)
  (string->symbol (constructVar (newName (var-lexer (open-input-string (format "~a" x)))))))

; Function that makes a naive rename over each variable that occurs in an expression generated by LF
(define-pass naive-rename-var : LF (ir) -> LF ()
  (Expr : Expr (ir) -> Expr ()
        [,x (let* ([newX (newVar x)])
              newX)]
        [(fun ((,x* ,t*) ...) ,t ,[body*] ... ,[body])
         (let* ([newXs (map newVar x*)])
         `(fun ((,newXs ,t*) ...) ,t ,body* ... ,body))]
        [(let ((,x* ,t* ,[e*]) ...) ,[body*] ... ,[body])
         (let* ([newXs (map newVar x*)])
         `(let ((,newXs ,t* ,e*) ...) ,body* ... ,body))]
        [(funF ,x ((,x* ,t*) ...) ,t ,[body*] ... ,[body])
         (let* ([newX (newVar x)] [newXs (map newVar x*)])
         `(funF ,newX ((,newXs ,t*) ...) ,t ,body* ... ,body))]))

; Function that renames each variable that occurs in an expression generated by LF so variables
; nested occurrences of the same variable are distinguished
(define-pass rename-var : LF (ir) -> LF ()
  (Expr : Expr (ir) -> Expr ()
        [,x (let* ([newX (newVar x)])
              newX)]
        [(fun ((,x* ,t*) ...) ,t ,[body*] ... ,[body])
         (let* ([newXs (map newVar x*)])
         (naive-rename-var `(fun ((,newXs ,t*) ...) ,t ,body* ... ,body)))]
        [(let ((,x* ,t* ,[e*]) ...) ,[body*] ... ,[body])
         (let* ([newXs (map newVar x*)])
         (naive-rename-var `(let ((,newXs ,t* ,e*) ...) ,body* ... ,body)))]
        [(funF ,x ((,x* ,t*) ...) ,t ,[body*] ... ,[body])
         (let* ([newX (newVar x)] [newXs (map newVar x*)])
         (naive-rename-var `(funF ,newX ((,newXs ,t*) ...) ,t ,body* ... ,body)))]))

(printf "\n====================  E4 =======================\n")
(printf "We present some examples for E4, rename-var is evaluated with the given inputs:\n")

(printf "\n1. Input is (funF sumita ((x Int) (y Int)) Int (+ (fun ((x Int) (y Int)) Int (+ x y)) x y)):\n")
(rename-var (parse-LF '(funF sumita ((x Int) (y Int)) Int (+ (fun ((x Int) (y Int)) Int (+ x y)) x y))))

(printf "\n2. Input is (+ x (funF sumita ((x Int) (y Int)) Int (+ (fun ((x Int) (y Int)) Int (+ x y)) x y))):\n")
(rename-var (parse-LF '(+ x (funF sumita ((x Int) (y Int)) Int (+ (fun ((x Int) (y Int)) Int (+ x y)) x y)))))

(printf "\n3. Input is (app (funF sumita ((x Int) (y Int)) Int (+ (fun ((x Int) (y Int)) Int (+ x y)) x y)) (funF sumita ((x Int) (y Int)) Int (+ (fun ((x Int) (y Int)) Int (+ x y)) x y))):\n")
(rename-var (parse-LF '(app (funF sumita ((x Int) (y Int)) Int (+ (fun ((x Int) (y Int)) Int (+ x y)) x y)) (funF sumita ((x Int) (y Int)) Int (+ (fun ((x Int) (y Int)) Int (+ x y)) x y)))))

(printf "\n4. Input is (fun ((x Int)) Int (+ x (let ((x Int 1)) (+ x (fun ((x Int)) Int (+ x (let ((x Int 2)) x))))))):\n")
(rename-var (parse-LF '(fun ((x Int)) Int (+ x (let ((x Int 1)) (+ x (fun ((x Int)) Int (+ x (let ((x Int 2)) x)))))))))

(printf "\n5. Input is (funF prueba ((u Int) (v Int) (w Int) (x Int) (y Int) (z Int)) Int (+ (- u (* (/ v w) x)) (* y z))):\n")
(rename-var (parse-LF '(funF prueba ((u Int) (v Int) (w Int) (x Int) (y Int) (z Int)) Int (+ (- u (* (/ v w) x)) (* y z)))))

(printf "\n6. Input is (funF prueba ((x Int) (y Int)) Int (+ (funF suma ((x Int) (z Int)) Int (+ x y z)) x y)):\n")
(rename-var (parse-LF '(funF prueba ((x Int) (y Int)) Int (+ (funF suma ((x Int) (z Int)) Int (+ x y z)) x y))))


;; ====================  E4 =======================

